class ByteArray{
	constructor(){
		this.bin = [];
		this.chr = [];
		for (let i = 0; i < 256; i++){
			this.chr[i] = String.fromCharCode(i);
		}
	}
	getData() {
		let v = '';
		for (let i = 0; i < this.bin.length; i++)
			v += this.chr[this.bin[i]];
		return v;
	}
	writeByte(val) {
		this.bin.push(val);
	}
	writeUTFBytes(string) {
		for (let i = 0; i < string.length; i++){
			this.writeByte(string.charCodeAt(i));
		}
	}
	writeBytes(array, offset, length) {
		let l = length || array.length;
		for (let i = offset || 0; i < l; i++){
			this.writeByte(array[i]);
		}
	}
	writeShort(pValue) {
		this.writeByte(pValue & 0xFF);
		this.writeByte((pValue >> 8) & 0xFF);
	}
}
class GIFEncoder{
	constructor(){
		this.width; // image size
		this.height;
		this.transparent = null; // transparent color if given
		this.transIndex; // transparent index in color table
		this.repeat = -1; // no repeat
		this.delay = 0; // frame delay (hundredths)
		this.hasStarted = false; // ready to output frames
		this.outputByteArray;
		this.currentFrame; // current frame
		this.pixels; // BGR byte array from frame
		this.indexedPixels; // converted frame indexed to palette
		this.colorDepth; // number of bit planes
		this.rgbPalette; // RGB palette
		this.usedEntry = []; // active palette entries
		this.palSize = 7; // color table size (bits-1)
		this.dispose = -1; // disposal code (-1 = use default)
		this.closeStream = false; // close stream when finished
		this.isFirstFrame = true;
		this.isSizeSet = false; // if false, get size from first frame
		this.sample = 10; // default sample interval for quantizer
		this.comment = "";//"Generated by jsgif (https://github.com/antimatter15/jsgif/)"; // default comment for generated gif
	}
	reset() {
		this.transIndex = 0;
		this.currentFrame = null;
		this.pixels = null;
		this.indexedPixels = null;
		this.rgbPalette = null;
		this.closeStream = false;
		this.isFirstFrame = true;
	}
	setDelay(ms) {
		this.delay = Math.round(ms / 10);
	}
	setDispose(code) {
		if (code >= 0) this.dispose = code;
	}
	setRepeat(iter) {
		if (iter >= 0) this.repeat = iter;
	}
	setTransparent(c) {
		this.transparent = c;
	}
	setComment(c) {
		this.comment = c;
	}
	setFrameRate(fps) {
		if (fps != 0xf) this.delay = Math.round(100 / fps);
	}
	setQuality(quality) {
		if (quality < 1) quality = 1;
		this.sample = quality;
	}
	setSize(w, h) {
		if (this.hasStarted && !this.isFirstFrame) return;
		this.width = w;
		this.height = h;
		if (this.width < 1) this.width = 320;
		if (this.height < 1) this.height = 240;
		this.isSizeSet = true;
	}
	setProperties(hasStarted, isFirstFrame) {
		this.hasStarted = hasStarted;
		this.isFirstFrame = isFirstFrame;
	}
	start() {
		this.reset();
		this.hasStarted = true;
		this.closeStream = false;
		this.outputByteArray = new ByteArray();
		try {
			this.outputByteArray.writeUTFBytes("GIF89a"); // header
		} catch (e) {
			console.log(e);
			this.hasStarted = false;
		}
		return this.hasStarted;
	}
	finish() {
		if (!this.hasStarted) return false;
		let ok = true;
		this.hasStarted = false;
		try {
			this.outputByteArray.writeByte(0x3b); // gif trailer
			this.closeStream=true;
		} catch (e) {
			console.log(e);
			ok = false;
		}
		return ok;
	}
	addCanvasFrame(im) {
		if ((im === null) || !this.hasStarted || this.outputByteArray === null) {
			throw new Error("Please call start method before calling addFrame");
		}
		let ok = true;
		try {
			this.currentFrame = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;
			if (!this.isSizeSet) this.setSize(im.canvas.width, im.canvas.height);
			this.getImagePixels(); // convert to correct format if necessary
			this.analyzePixels(); // build color table & map pixels
			if (this.isFirstFrame) {
				this.writeLSD(); // logical screen descriptior
				this.writePalette(); // global color table
				if (this.repeat >= 0) {
					this.writeNetscapeExt();
				}
			}
			this.writeGraphicCtrlExt(); // write graphic control extension
			if (this.comment !== '') {
				this.writeCommentExt(); // write comment extension
			}
			this.writeImageDesc(); // image descriptor
			if (!this.isFirstFrame) this.writePalette(); // local color table
			this.writePixels(); // encode and write pixel data
			this.isFirstFrame = false;
		} catch (e) {
			console.log(e);
			ok = false;
		}
		return ok;
	}
	cont() {
		this.reset();
		this.hasStarted = true;
		this.closeStream = false;
		this.outputByteArray = new ByteArray();
		return this.hasStarted;
	}
	analyzePixels() {
		this.usedEntry = [];
		let len = this.pixels.length;
		let nPix = len / 3;
		this.indexedPixels = [];
		let nq = new NeuQuant(this.pixels, len, this.sample);
		this.rgbPalette = nq.process(); // create reduced palette
		let k = 0;
		let index;
		for (let j = 0; j < nPix; j++) {
			index = nq.map(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);
			this.usedEntry[index] = true;
			this.indexedPixels[j] = index;
		}
		this.pixels = null;
		this.colorDepth = 8;
		this.palSize = 7;
		if (this.transparent !== null) {
			this.transIndex = this.findClosest(this.transparent);
		}
	}
	findClosest(c) {
		if (this.rgbPalette === null) return -1;
		let r = (c & 0xFF0000) >> 16;
		let g = (c & 0x00FF00) >> 8;
		let b = (c & 0x0000FF);
		let minpos = 0;
		let dmin = 256 * 256 * 256;
		let len = this.rgbPalette.length;
		let dr, dg, db, d, index;
		for (let i = 0; i < len;) {
			dr = r - (this.rgbPalette[i++] & 0xff);
			dg = g - (this.rgbPalette[i++] & 0xff);
			db = b - (this.rgbPalette[i] & 0xff);
			d = dr * dr + dg * dg + db * db;
			index = (i + 1) / 3;
			if (this.usedEntry[index] && (d < dmin)) {
				dmin = d;
				minpos = index;
			}
			i++;
		}
		return minpos;
	}
	getImagePixels() {
		let w = this.width;
		let h = this.height;
		this.pixels = [];
		let data = this.currentFrame;
		let count = 0;
		let b;
		for (let i = 0; i < h; i++) {
			for (let j = 0; j < w; j++) {
				b = (i * w * 4) + j * 4;
				this.pixels[count++] = data[b];
				this.pixels[count++] = data[b + 1];
				this.pixels[count++] = data[b + 2];
			}
		}
	}
	writeGraphicCtrlExt() {
		this.outputByteArray.writeByte(0x21); // extension introducer
		this.outputByteArray.writeByte(0xf9); // GCE label
		this.outputByteArray.writeByte(4); // data block size
		let transp;
		let disp;
		if (this.transparent === null) {
			transp = 0;
			disp = 0; // dispose = no action
		} else {
			transp = 1;
			disp = 2; // force clear if using transparent color
		}
		if (this.dispose >= 0) {
			disp = this.dispose & 7; // user override
		}
		disp <<= 2;
		this.outputByteArray.writeByte(0 | // 1:3 reserved
			disp | // 4:6 disposal
			0 | // 7 user input - 0 = none
			transp); // 8 transparency flag
		this.outputByteArray.writeShort(this.delay); // delay x 1/100 sec
		this.outputByteArray.writeByte(this.transIndex); // transparent color index
		this.outputByteArray.writeByte(0); // block terminator
	}
	writeCommentExt() {
		this.outputByteArray.writeByte(0x21); // extension introducer
		this.outputByteArray.writeByte(0xfe); // comment label
		this.outputByteArray.writeByte(this.comment.length); // Block Size (s)
		this.outputByteArray.writeUTFBytes(this.comment);
		this.outputByteArray.writeByte(0); // block terminator
	}
	writeImageDesc() {
		this.outputByteArray.writeByte(0x2c); // image separator
		this.outputByteArray.writeShort(0); // image position x,y = 0,0
		this.outputByteArray.writeShort(0);
		this.outputByteArray.writeShort(this.width); // image size
		this.outputByteArray.writeShort(this.height);
		if (this.isFirstFrame) {
			this.outputByteArray.writeByte(0);
		} else {
			this.outputByteArray.writeByte(0x80 | // 1 local color table 1=yes
				0 | // 2 interlace - 0=no
				0 | // 3 sorted - 0=no
				0 | // 4-5 reserved
				this.palSize); // 6-8 size of color table
		}
	}
	writeLSD() {
		this.outputByteArray.writeShort(this.width);
		this.outputByteArray.writeShort(this.height);
		this.outputByteArray.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)
			0x70 | // 2-4 : color resolution = 7
			0x00 | // 5 : gct sort flag = 0
			this.palSize)); // 6-8 : gct size
		this.outputByteArray.writeByte(0); // background color index
		this.outputByteArray.writeByte(0); // pixel aspect ratio - assume 1:1
	}
	writeNetscapeExt() {
		this.outputByteArray.writeByte(0x21); // extension introducer
		this.outputByteArray.writeByte(0xff); // app extension label
		this.outputByteArray.writeByte(11); // block size
		this.outputByteArray.writeUTFBytes("NETSCAPE" + "2.0"); // app id + auth code
		this.outputByteArray.writeByte(3); // sub-block size
		this.outputByteArray.writeByte(1); // loop sub-block id
		this.outputByteArray.writeShort(this.repeat); // loop count (extra iterations, 0=repeat forever)
		this.outputByteArray.writeByte(0); // block terminator
	}
	writePalette() {
		this.outputByteArray.writeBytes(this.rgbPalette);
		let n = (3 * 256) - this.rgbPalette.length;
		for (let i = 0; i < n; i++) this.outputByteArray.writeByte(0);
	}
	writePixels() {
		let myencoder = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);
		myencoder.encode(this.outputByteArray);
	}
	getByteArray() {
		return this.outputByteArray;
	}
	download(filename) {
		if(this.outputByteArray===null || this.closeStream==false) {
			console.log("Please call start method and add frames and call finish method before calling download"); 
		} else {
			filename = filename !== undefined ? ( filename.endsWith(".gif")? filename: filename+".gif" ): "download.gif";
			let templink = document.createElement("a");
			templink.download=filename;
			templink.href= URL.createObjectURL(new Blob([new Uint8Array(out.bin)], {type : "image/gif" } ));
			templink.click();
		}
	}
}
